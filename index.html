<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8 />
    <title>News cloud</title>
    <link rel="stylesheet" type="text/css" href="./reset.css" />
    <link rel="stylesheet" type="text/css" href="./main.css" />
  </head>
  <body>
    <header>
      <div id="container">
        <!-- 사이트 정보(왼쪽 상단에 배치) -->
        <div id="site_info">
          <a href="./index.html">
            <img src="./resource/title.png" alt="tag cloud">
          </a>
        </div>

        <!-- 각각의 카테고리에 해당하는 기사만 보여주는 퀵 링크(사이트 정보 하단에 배치) -->
        <div id="category_quick_link">
          <nav id="news_category">
            <ul>
              <li>
                <a href="http://news.naver.com/main/main.nhn?mode=LSD&mid=shm&sid1=104">World</a>
              </li>
              <li>
                <a href="http://news.naver.com/main/main.nhn?mode=LSD&mid=shm&sid1=100">Politics</a>
              </li>
              <li>
                <a href="http://news.naver.com/main/main.nhn?mode=LSD&mid=shm&sid1=105">Tech</a>
              </li>
              <li>
                <a href="http://news.naver.com/main/list.nhn?mode=LS2D&mid=shm&sid1=105&sid2=228">Science</a>
              </li>
              <li>
                <a href="http://news.naver.com/main/list.nhn?mode=LS2D&mid=shm&sid1=103&sid2=241">Health</a>
              </li>
              <li>
                <a href="http://news.naver.com/main/list.nhn?mode=LS2D&mid=shm&sid1=102&sid2=256">Local</a>
              </li>
            </ul>
          </nav>
        </div>

        <!-- 개인화 메뉴(오른쪽 상단에 배치) -->
        <div id="sign_in">
          <div>
            <a href="https://nid.naver.com/nidlogin.login?svctype=64&url=http://newsstand.naver.com/login_after.html/">sign in</a>
          </div>
          <div>
            <a href="https://nid.naver.com/nidlogin.login?svctype=64&url=http://newsstand.naver.com/login_after.html/">contact</a>
          </div>
          <div>
            <a href="https://nid.naver.com/nidlogin.login?svctype=64&url=http://newsstand.naver.com/login_after.html/">about</a>
          </div>
        </div>

        <!-- 검색 박스(개인화 메뉴 바로 아래에 배치) -->
        <div id="search_box">
          <a href="http://se.naver.com/">
            <img src="./resource/search_arrow.png" alt="search">
          </a>
        </div>

        <!-- sns를 이용한 회원가입(왼쪽 하단에 배치) -->
        <div id="join_us">
          <nav id="join_link">
            <ul class="link_horizontal">
              <li>
                <a href="http://www.twitter.com/">
                  <img src="./resource/join_tw.png" alt="twitter">
                </a>
              </li>
              <li>
                <a href="http://plus.google.com/">
                  <img src="./resource/join_gp.png" alt="google+">
                </a>
              </li>
              <li>
                <a href="http://www.facebook.com/">
                  <img src="./resource/join_fb.png" alt="facebook">
                </a>
              </li>
            </ul>
          </nav>
          <div>
            join us
          </div>
        </div>
      </div>
    </header>

    <div id="main_contents">
      <div id="container">
        <!-- 뉴스 태그(main contents 중앙 상단에 배치) // temp image -->
        <div id="tag_cloud">
	        <ul id="tags">
	        	<li>
		        	<div>
		        		<canvas id="canvas_test" width="1180px" height="580px">
		        		</canvas>
		        	<div>
		        </li>
		        <li>
		        	<div>
		        		<img src="./resource/tagcloud_01.jpg" alt="temp image">
		        	<div>
		        </li>
		        <li>
		        	<div>
		        		<img src="./resource/tagcloud_02.jpg" alt="temp image">
		        	<div>
		        </li>
		        <li>
		        	<div>
		        		<img src="./resource/tagcloud_03.jpg" alt="temp image">
		        	<div>
		        </li>
		        <li>
		        	<div>
		        		<img src="./resource/tagcloud_04.jpeg" alt="temp image">
		        	<div>
		        </li>
	        </ul>
        </div>

        <!-- 메뉴 (main contents 내부 우측 하단에 배치) -->
        <div id="control_menu">
          <ul>
            <li id="refresh">
              <img src="./resource/b5.png" alt="filter">
            </li>
            <li id="auto_scroll">
              <img src="./resource/b4.png" alt="auto_scroll">
            </li>
            <li id="refresh">
              <img src="./resource/b3.png" alt="refresh">
            </li>
            <li id="next_page">
              <img src="./resource/b1.png" alt="next_page">
            </li>
            <li id="previous_page">
              <img src="./resource/b2.png" alt="previous_page">
            </li>
          </ul>
        </div>
      </div>
    </div>

    <!-- 신문사 선택(main contents 하단에 배치) -->
    <div id="selet_newspaper">
      <div id="container">
        <ul id="newspapers">
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
          <li></li>
        </ul>
      </div>
    </div>

    <!-- 저작권 표시(외부 링크 영역 하단에 배치) -->
    <footer>
      <div id="container">
        <div>
          © 2013 Choi Gyeongwook
        </div>
      </div>
    </footer>
    <script>
	    /*
		    canvas study
	    */
	    
	    /*
	    	color table
	    	light blue 	: 30, 153, 197
	    	deep blue 	: 7, 104, 172
	    	purple 		: 96, 2, 126
	    	magenta 	: 196, 15, 132
	    	red 		: 254, 0, 8
	    	orange 		: 255, 102, 0
	    	yellow 		: 255, 178, 0
	    	lime 		: 204, 232, 36
	    	green 		: 115, 191, 31
	    	jade 		: 78, 183, 153
	    */
	    	    
	    //일단 상수로 담아두자 - 나중에 동적으로 받아올 것
	    var canvasWidth = 1180;
	    var canvasHeight = 580;
	    
	    //조심해!
	    //나중에 업데이트된 키워드 중에서 이미 리스트에 있다면 그 자리에 업데이트 된 빈도수를 바꿔줘야 계속 같은 위치 유지
	    //그러니까 딕셔너리 타입으로 가야 될 수도 있겠네...
	    //태그 클라우드에 표시될 단어들의 내용과 빈도수를 담아두는 변수
	    var tagWords = [];
	    
	    function createTag(idx, keyword, frequency, tagList){
	    	var obj = new Object();
	    	obj.idx = idx;
	    	obj.keyword = keyword;
	    	obj.frequency = frequency;
	    	obj.diameter = keyword.length * 14; //빈도에 따라서 한 글자의 크기가 달라지므로 나중에 frequency와 상수 곱해줄 것
	    	//가운데 몰려서 생성되게 설정
	    	obj.xPos = Math.floor(Math.random() * canvasWidth / 2) + canvasWidth / 4;
	    	obj.yPos = Math.floor(Math.random() * canvasHeight / 2) + canvasHeight / 4;
	    	
	    	//아래 움직임에 관련된 상수들 나중에 따로 변수에 담아둘 것
	    	obj.xVelocity = Math.floor(Math.random() * 1);
	    	obj.yVelocity = Math.floor(Math.random() * 1);
	    	obj.xAcceleration = Math.floor(Math.random() * 1);
	    	obj.yAcceleration = Math.floor(Math.random() * 1);

	    	obj.color = "rgb(7, 104, 172)"; //일단 하드 코딩 : 나중에 테이블 만들어 두고 랜덤하게 또는 빈도에 따라서 색 지정할 것
	    	obj.otherTags = tagList;
	    	
	    	// 태그들이 매 프레임마다 하는 일은
	    	// 일단 다른 태그들과 겹치는지 체크해서 겹치면 서로 반대방향으로 속도 증가 시킴(거리에 비례해서)
	    	// 그 다음은 지금 설정된 속도대로 움직임 - 좌표 변경
	    	// 이 작업의 반복
	    	obj.collide = function(){
	    		//console.log("collide start");
	    	
		    	for (var i = 0; i < this.idx; ++i){
			    	//check the collision with each tags
			    	var dx = this.otherTags[i].xPos - this.xPos;
			    	var dy = this.otherTags[i].yPos - this.yPos;
			    	var distance = Math.sqrt( (dx * dx) + (dy * dy) );
			    	
			    	var weight = this.diameter + this.otherTags[i].diameter - distance;
			    	
			    	if (weight > 0){
			    		//값이 너무 크면 dx, dy를 0 ~ 1 사이의 값으로 변경할 것
			    		xWeight = weight * dx * 0.01;
			    		yWeight = weight * dy * 0.01;
			    		
			    		this.xVelocity -= xWeight;
			    		this.yVelocity -= yWeight;
			    		
			    		this.otherTags[i].xVelocity += xWeight;
			    		this.otherTags[i].yVelocity += yWeight;
			    	}
		    	}
		    	
		    	//console.log("collide end");
	    	}
	    	
	    	obj.move = function(){
	    		//console.log("move start");
	    		
	    		//마찰력을 넣으면 여기서 가속도와 속도 모두 변경해야 하려나?
	    		//현재 속도의 반대 방향으로 가속도를 주자!
	    		
	    		//속도 업데이트
	    		this.xVelocity += this.xAcceleration;
	    		this.yVelocity += this.yAcceleration;
	    		
	    		//위치 이동
	    		this.xPos += this.xVelocity;
	    		this.yPos += this.yVelocity;
	    		
	    		//화면 밖으로 나가는 경우 반대 방향으로 튕겨준다.
	    		if (xPos < 0 + this.diameter / 2){
	    			xPos = this.diameter;
	    			xVeolocity *= -1;
	    		} else if (xPos > canvasWidth - this.diameter / 2){
	    			xPos = canvasWidth - this.diameter;
	    			xVelocity *= -1;
	    		}
	    		
	    		if (yPos < 0 + this.diameter / 2){
	    			yPos = this.diameter;
	    			yVelocity *= -1;
	    		} else if (yPos > canvasHeight - this.diameter / 2){
	    			yPos = canvasHeight - this.diameter;
	    			yVelocity *= -1;
	    		}
	    		
	    		//console.log("move end");
	    	}
	    	
	    	return obj;
	    }
	    
	    //단어들의 변경된 정보를 5분마다 서버에서 새로 받아와서 receivedTagWords의 내용을 업데이트한다.
	    var refreshTime = 5 * 60 * 1000; //5min
	    var tagSrcURL = "sampleTags.json";
	    
	    var refreshTags = function(){
	    	console.log("refresh");
	    	
	    	var receivedTagWords = null;
		    var tagRequest = new XMLHttpRequest();
		    tagRequest.open("GET", tagSrcURL, false);
	    	tagRequest.send(null);
	    	
	    	//서버에서 업데이트 된 태그 정보를 받아 온 후에 데이터를 교환해야 하므로 동기적으로 작동되어야 한다.
		    receivedTagWords = JSON.parse(tagRequest.responseText);
		    console.log(receivedTagWords);
		    
		    for (var i = 0, count = receivedTagWords.length; i < count; ++i){
		    	//최초 생성이 아니라 이미 생성된 리스트를 업데이트하는 경우에는 할당된 태그 오브젝트를 삭제
		    	if (tagWords[i] != undefined){
		    		delete tagWords[i];
		    	}
		    	
		    	//새로 받아온 데이터를 기반으로 태그 오브젝트 생성
				tagWords[i] = createTag(i, receivedTagWords[i][0], receivedTagWords[i][1], tagWords);
		    }
		    
		    //맨처음에 한 번 태그 정보를 업데이트한 뒤에는 setInterval()로 주기적으로 업데이트
		    //(시간 간격 동안 기다렸다가 자기 자신을 하나 더 호출하고 자신은 종료)
		    setTimeout(refreshTags, refreshTime) //5분마다 태그 데이터 업데이트
	    }
	    
	    //인자를 받아서 그리면 재귀가 안 끝난다. 오버헤드가 낮은 방법으로 함수 안에서 context에 접근할 수 있도록 할 것
	    var drawTags = function(){
		    console.log("draw");
		    
			//조심해! - 하드코딩
			//context = 
			context.clearRect ( 0, 0, 1180, 580);
			
			for (var i = 0, count = tagWords.length; i < count; ++i){
				context.font = "18px Tahoma"; //나중에 obj에서 정보 가져와서 넣을 것
				context.texAlign = "center";
				context.textBaseLine = "middle";
				
				context.fillStyle = tagWords[i].color;
				
				tagWords[i].collide();
				tagWords[i].move();
				
				context.fillText(tagWords[i].keyword, tagWords[i].xPos, tagWords[i].yPos);
			}
			
			console.log("for out!");
			
			setTimeout(drawTags, 20);
			
			console.log("draw end");
	    }
	    
	    // canavas 설정
	    var drawing = document.getElementById("canvas_test");
	    
	    var xPos;
	    var yPos;
	    
	    if (drawing.getContext){
	    	//테스트를 위해 전역으로 변경
	    	context = drawing.getContext("2d");
	    
	    	//태그 정보를 업데이트하고
	    	refreshTags();
	    	
			//주기적으로 현재의 tag data를 기반으로 화면에 그린다.
			//var drawTagsID = setInterval(drawTags(context), 20);
			drawTags();
			//drawTagsID = setInterval(drawTags, 200)
			
	    }
	    //var drawTagsID = setInterval(drawTags(context), 200);
			
	   
	    /*
		    각 신문사에게 임의의 가중치를 부여하고 가중치가 높은 신문사 10개를 추출해서 웹페이지 하단에 노출
	    */
	    var newsPaperList = [
	    						['경향신문', 'http://www.khan.co.kr/', 0],
	    						['오마이뉴스', 'http://www.ohmynews.com/', 0],
	    						['ZDNet Korea', 'http://www.zdnet.co.kr/', 0],
	    						['블로터닷넷', 'http://www.bloter.net/', 0],
	    						['한겨례', 'http://www.hani.co.kr/', 0],
	    						['중앙일보', 'http://joongang.joins.com/', 0],
	    						['조선일보', 'http://www.chosun.com/', 0],
	    						['동아일보', 'http://www.donga.com/', 0],
	    						['과학동아', 'http://www.dongascience.com/', 0],
	    						['시사IN Live', 'http://www.sisainlive.com/', 0],
	    						['THE KOREA TIMES', 'http://www.khan.co.kr/', 0],
	    						['THE WALL STREET JOURNAL', 'http://kr.wsj.com/home-page', 0]
	    					];
	    					
	    newsPaperList.forEach(function(item){
		    item[2] = Math.floor(Math.random() * 20);
		    });
		    
		function compare(value1, value2){
			if (value1[2] < value2[2]) {
				return 1;
			} else if (value1[2] > value2[2]){
				return -1;
			} else {
				return 0;
			}
		}
		
		newsPaperList.sort(compare);
		
	    newsPaperArray = [];
	    newsPaperArray = document.querySelectorAll("#newspapers > li");
	    
	    //console.log(newsPaperArray);
	    
	    htmlLength = newsPaperArray.length;
	    
	    for(var i = 0; i < htmlLength; ++i){
	    	newsPaperArray[i].insertAdjacentHTML(
	    	'afterbegin', "<div><a href=" + newsPaperList[i][1] + ">" + newsPaperList[i][0] + "</a></div>"
	    	);
	    }
	    
	    /*
		    tag cloud scroll
	    */
	    var scrollDirection = {
		    'PREVIOUS' : 0,
		    'NEXT' : 1,
		    'AUTO' : 2
	    }
	    
	    
	    //조심해!
	    //태그 이름도 변수로 뺄까?
	    
	    //스크롤되는 태그 페이지 수(태그 클라우드가 생성된 신문사의 수)
	    var tagPageNumber = document.querySelectorAll("#tag_cloud > ul > li").length;
	    
	    //스크롤되는 단위 크기 = 태그 클라우드 표시 영역의 가로 길이
	    var tagElement = document.getElementById("tag_cloud");
	    var TagCloudWidth = parseInt(window.getComputedStyle(tagElement,null).getPropertyValue("width"), 10);
	    
	    //animation 관련 변수
	    var scrollTime = 700; //500ms
	    var animationInterval = 50; //10ms
	    var animationFlag = false; //애니메이션 재생 도중 입력에 의한 오류 제어
	    
	    var controlMenu = document.getElementById("control_menu");
	    
	    //이동되는 방향에 따른 이벤트 콜백 함수 생성
	    //조심해! - 나중에 자동 스크롤 기능 추가할 것
		var scroll = function(e, direction){
			//console.log("scroll()");
			
			//현재 애니메이션이 진행 중이라면 이번 입력은 처리하지 않는다.
			//사용자가 불편하다면 나중에 버퍼에 담아두고 재생이 완료된 후에 재생할 수도...?
			if(animationFlag)
				return;
			
			//애니메이션을 적용할 타겟 설정
			var tags = document.getElementById("tags");
			var startPosition = parseInt(window.getComputedStyle(tags,null).getPropertyValue("left"), 10);
			var animationDirection; //스크롤 방향 : 다음 페이지인 경우 타겟이 왼쪽으로 이동하므로 -1, 이전 페이지이면 반대
			
			switch(direction){
			case scrollDirection['NEXT']:
		        if (startPosition <= -TagCloudWidth * (tagPageNumber - 1) )
		        	return;
		        	
	        	animationDirection = -1;
		        break;
		    case scrollDirection['PREVIOUS']:
				if (startPosition >= 0)
		        	return;
		        
		        animationDirection = 1;
		        break;
		    default:
		    	//현재 이벤트가 준비된 버튼이 아닌 경우 linkEvent()에서 필터링 되지만, 만약 진입하더라도 여기서 중지
		        return;  	
		    }
		    
		    animationFlag = true;
		    var animationKeyFrame = 0;
		    //console.log(startPosition);
	
			//애니메이션 재생 시작으로부터 현재까지의 시간 값을 인자로 받아서 타겟을 적절한 위치로 이동 시킴
			var move = function(frame){
				//console.log("move()");
				
				var leftValue = startPosition + (animationDirection * TagCloudWidth * Math.sin( (Math.PI / 2) * (frame / scrollTime) ) );
			    
			    //console.log(startPosition);		    
				//console.log(leftValue);
			    tags.style.left = leftValue + "px";	
			}
			
		    //주기적으로 불리어져서 현재 타겟이 위치할 위치값(전체 이동해야 할 거리에 대한 비율)을 계산해서 이동시키는 함수 호출
		    //목표지점에 도달하면 setInterval 종료
		    var scrollAnimation = function(){
		    	//console.log("scrollAnimation()");
			
			    animationKeyFrame += animationInterval;
			    
			    if (animationKeyFrame >= scrollTime){
			    	animationKeyFrame = scrollTime;
			    	animationFlag = false;
			    	clearInterval(animationIntervalID);
			    }
			    
			    //console.log(animationKeyFrame);
			    move(animationKeyFrame);
			    
		    }
		    
		    var animationIntervalID = setInterval(scrollAnimation, animationInterval);
		}
		
		//이벤트가 발생한 타겟에 적절한 이벤트를 연결    
		var linkEvent = function(e){
			var target = e.target.parentNode;
			
			if (target.id === "next_page")
			{
				scroll(e, scrollDirection['NEXT']);
			}
			if (target.id === "previous_page")
			{
				scroll(e, scrollDirection['PREVIOUS']);
			}
		}
	    
	    controlMenu.addEventListener('click', function(e){linkEvent(e)}, false);
    </script>
  </body>
</html>